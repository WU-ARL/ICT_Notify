# Introduction to ICT-Notify

This tutorial does not go deep into the details on how ICT-Notify works. Its primary objectives are to establish some intuition about the library, and to get users started with a working example.

## Overview

As a motivating example, imagine we have a number of sensors that need to report certain measurements and status to a controller, which will incorporate the information from the sensors and make adjustments to the pertinent procedures if necessary. There are pain points in the NDN ecosystem for such a scenario. First, we cannot push data in NDN, so there is added latency incurred due to the controller needing to request the data. This is particularly unsatisfying for a scenario that is clearly fit for push-based semantics, as opposed to pull-based. Second, and more importantly, the current sync primitives are too heavyweight of data transfer mechanisms to be a good fit for small sensor updates. There is a significant amount of extra packets and bytes being sent to disseminate such small amounts of information. The more regular the interval of sensor updates, the more this overhead is exacerbated. ICT-Notify was created to remedy these two pain points.

ICT-Notify leverages long-lived interests in order to allow for push-based semantics, even in a pull-based architecture like NDN. The long-lived interests sit in the PIT of the hosts, and the data generated by a producer will satisfy that request (instead of needing it specifically asked for). This reduces the latency necessary to disseminate these updates from the RTT to the one-way delay. Much of the design effort of ICT-Notify went into the protocol’s namespace design. One significant priority was supporting multiple data producers with the benefits of the one-way delay. In the transfers, producers publish notification lists that can contain a configurable set of notifications (as opposed to just one notification per update). The other significant portion of the namespace design was to support set-difference calculations that let the consumers know what updates they have seen and what updates they haven’t. 

There are multiple structures supported to serve as the notification lists that are exchanged. The primary structure is Invertible Bloom Filters (IBFs). IBFs naturally support set-difference style operations, making it quite easy to reveal which notification events were previously known and which events are new.  Another supported structure is simply a vector of notification events. These do not allow for as efficient of set-difference calculations, but are more space efficient than their IBF counterparts. In order to reduce the memory demand in either case, the notification lists can be compressed in order to save necessary space on the wire. There is a substantial incentive to keep the notification packets from being fragmented.

The ICT-Notify API can be found in src/api.hpp and src/api.cpp. The API itself is quite simple. The two main functions with which users interact with the library are init and notify. The init function initializes the library for subscribing to notifications, and calling a user-provided function when the notifications are received. In other words, the user provides a callback to the init function that will be invoked when events are received. It also provides a filename which the ICT-Notify API reads. This file must be a configuration file that, among other things, specifies the list of names that the notify API should filter events on. These two pieces are necessary for the program to receive events. The notify function exists to publish any events on that machine. The user must provide the notification list (the list of events) to this notify function. The events can hold arbitrary information, so long as they are represented in an NDN name. The respective function prototypes (slightly adapted for brevity) may be found below:

```C++
using NotificationAppCallback = 
    function<void(uint64_t receivedTime, 
                  const std::unordered_map<uint64_t, std::vector<Name>>&)>;

void init(const std::string& filename, const NotificationAppCallback& notificationCB);

void notify(const Name& notificationName,
              const std::vector<Name>& eventList,
              const ndn::time::milliseconds& freshness);
```

## Hands-on examples
Our example use-case is an application that wants to receive status information from a variety of devices. This scenario is vague enough that it can model a number of real life scenarios, the most straightforward of which being sensor networks.

### Mapping the scenario to ICT-Notify
In the scenario described above, our service consists of the devices sharing status updates (producers) and the device receiving the status updates (consumer). In order to disseminate / receive events using ICT-Notify, the producers and consumers must all be speaking on the same namespace. To this end, the service must have a notification namespace (or notification name for short), which is a valid NDN name. The notification namespace for our sample application is /wustl/test/service.

However, in a notification namespace, there may be different types of events that we want to filter on. Maybe one consumer only cares about event types A and B, but another consumer cares about event types B and C. As a result, we need an event name for each event in the notification namespace. In our sample application, we only use one event: /test/event.

When the notification name is concatenated with the event name, we end up with the valid NDN name /wustl/test/service/test/event. This name is how events of type /test/event would be published in NDN. ICT-Notify acts as the middle-man between our application and the NDN network, performing the processing on this name to only notify us of events we have filtered on.

In order to tell ICT-Notify important parameters like the notification name and event names our application is going to filter on, we need to pass it a configuration file. This configuration file also must specify what data structure ICT-Notify should use to represent multiple events. For the purposes of this tutorial, we default to the invertible bloom filter. Lastly, the configuration file can contain certain parameters like the default interest lifetime, if the application is a producer or consumer (or both simultaneously), etc. We provide the full configuration file for the tutorial below, with the most important settings highlighted in bold.

```yaml
notification
{
        name /wustl/test/service
        maxMemorySize 50
        memoryFreshness 7
        lifetime 1
        isListener true
        isProvider true
        stateType IBF
        event
        {
                filter
                {
                        type name
                        name /test/event/
                        relation is-prefix-of
                }
        }
}
```

Now we will walk through how to use ICT-Notify to make our first applications. The entire source code for these programs may be found in the tutorials directory. The applications for the first example are quite straightforward (consumer.cpp and producer.cpp). After we feel comfortable with using the API in a basic consumer and producer, we incorporate a few more interesting details with the second example (consumer-with-state.cpp).

### Basic consumer and producer

We should be explicit that NFD must already be running (and pertinent FIB entries configured) in order for an ICT-Notify producer / consumer to function. The communication with NFD, as well as the underlying functionality of the library, is presented to the user as an API object we call the notification handler. As seen below, this API object is declared as a pointer.

```C++
std::shared_ptr<notificationLib::api> m_notificationHandler;
```

In order for the API to function properly, it needs to be initialized once and only once. For both our producer and consumer, we write an init function to perform this initialization. This function can be seen in the code sample below.

```C++
void init()
{
    if (m_notificationHandler != nullptr) {
        std::cout << "Trying to initialize notification handler, but it already exists";
        return;
    }

	m_notificationHandler = std::make_shared<notificationLib::api>(m_face,
	                                                               notificationLib::api::DEFAULT_NAME,
	                                                               notificationLib::api::DEFAULT_VALIDATOR);
    m_notificationHandler->init(m_fileName,
	                            std::bind(&NotificationConsumer::onNotificationUpdateWithTime, this, _1, _2));
      
    sleep(2);
}
```

We first check to make sure the notification handler isn’t already initialized. Assuming it is not, we initialize the notification handler object itself by providing (i) the face that the ICT-Notify app should use in the NFD instance, (ii) the name of the signing ID, and (iii) the name of the validator to be used. If no signing ID or validator are wanted, pass the default name and validator as seen in the above code. Currently, ICT-Notify does not support validation anyway.

After we initialize our notification handler object, we use it to call the initialization function provided by the handler, which tells the ICT-Notify library what events we want to listen on, and how we will react to those events. Specifically, the arguments provided are (i) the name of the provided configuration file, which contain the names of the events the library will filter on for our application, and (ii) a callback to a function in our consumer that will handle the events that are passed to us by the library. This function is only necessary if you want to receive events, hence the specific code sample shown is that of the tutorial consumer. Lastly, we add a sleep to allow some time for things to get initialized and configured.

The callback argument for the API’s init function deserves a closer look. In our consumer class, we have the following function:

```C++
void
onNotificationUpdateWithTime(uint64_t receivedTime,
                             const NotificationMap& notiMap)
{
    for (auto& map_itr : notiMap)
    {
        for (auto& noti : map_itr.second)
        {
            if (DEBUG) {
                std::cout << "application received notification (t = "
                         << receivedTime << "): " << noti << std::endl;
            }

            int status = std::stoi( noti.get(-1).toUri() );
            double longitude = std::stod( noti.get(-2).toUri() );
            double latitude = std::stod( noti.get(-3).toUri() );
            std::string entityName( noti.get(-4).toUri() );

            std::cout << entityName << ": "
                      << latitude << "," << longitude << "\t"
                      << status2str(status) << std::endl;
        }
    }
}
```

Notification map is a typedef we created for readability. The actual underlying data structure is an unordered map where the key is a timestamp and the value is the notification list. These are provided by the ICT-notify library, and this is the format we must parse as the application to extract our events. The specific types in the notification map can be seen in the definition below:

```C++
typedef std::unordered_map<uint64_t, std::vector<Name>> NotificationMap;
```

It is up to the application developer how they want their events to be structured and packed into the NDN name, but by far the simplest approach is to append each distinct variable as an additional component to the notification name. We can see in our example how the onNotificationUpdateWithTime function parses this structure and the events embedded inside of the notification list. 

Tying this into our scenario, imagine we have a sensor named ‘sensor 1’, and it needs to publish its latitude, longitude, and status (38.6495424, -90.3076821, Good). At this point, the full event name that ICT-Notify will get from our application is /wustl/test/service/test/event/sensor 1/38.6495424/-90.3076821/Good. Our onNotificationUpdateWithTime function would parse these distinct status variables embedded in the event and display them.

Thus far we have initialized the notification handler and provided the ICT-Notify library with our callback to process the notifications that match our filter. All of this happened in the init function of our ICT-Notify consumer. The setup is completed. However, the program will exit unless we explicitly block execution for our NDN face to process packets. The listen function below accomplishes this, and is what we call immediately after the initialization function in our consumer.

```C++
void listen()
{
    m_face.processEvents();
}
```

Those are the key steps for writing an ICT-Notify consumer. Now we can discuss how to write an ICT-Notify producer, but much of the groundwork has already been laid. The producer must also initialize the notification handler object, much like the consumer did. However, it does not need to call the init function, as that is only to register that we want to receive a particular notification from the library. Instead, whenever we want to publish a notification, we tell the ICT-Notify library through the notification handler that we want to publish a notification. This is accomplished by the notify function of the ICT-Notify API, the other core function.

In our example producer, we randomly generate all of the event values for our notifications -- each device will have a randomly generated status, latitude, and longitude for each update. This can be seen in the code below, which is the generate function from our example producer.

```C++
void
generate()
{
    std::random_device rd;
    std::mt19937 gen( rd() );
    std::uniform_real_distribution<> latDist(-90.0, 90.0);
    std::uniform_real_distribution<> longDist(-180.0, 180.0);

    while (true)
    {
        m_face.processEvents( time::seconds(1) );
            
        // generate a random event
        TutorialEvent event { latDist(gen), longDist(gen), Status(std::rand() % 2) };

        // create our event by adding additional named components
        Name eventName("/test/event/");
        eventName.append(m_entityName);
        eventName.append( std::to_string(event.latitude) );
        eventName.append( std::to_string(event.longitude) );
        eventName.append( std::to_string(static_cast<int>(event.status)) );

        // add our event to an eventList
        std::vector<Name> eventList;
        eventList.push_back(eventName);

        // publish the event list under the notify namespace
        std::cout << "sending event = " << eventName << std::endl;
        m_notificationHandler->notify("/wustl/test/service", eventList);
            
        sleep(1);
    }
}
```

There are a number of practical details to discuss. First, the notify function takes the notification namespace as its first argument, and the event list as its second. This is an important point, because we can publish an entire list of notifications at a time (not just one). Second, this is the producer end of our application’s event formatting, where we simply append the status update variables to the end of the event name. Notice the event name, this is the name of the event in the configuration file. We can see the notification namespace is completely separate in the producer, and will be concatenated with the event name by the ICT-Notify library itself. 

The most important practical detail is the treatment of the processEvents function. We must call processEvents, otherwise our notify calls will not work because the face isn’t processing packets. However, we cannot call processEvents without an argument like we did in the consumer, because it would block forever and we would be unable to generate more data. Instead, we pass an optional timeout argument for the processEvents function, which is the threshold when it will stop blocking and we will retain program execution in the producer. We publish these events at a 1 second interval. 

Also, our producer is actually a combined producer/consumer, as it also has the ability to receive and display notifications. So in the example’s producer code, it also calls the ICT-Notify init function. We want to abundantly clear, this is only necessary if you want to receive events and not at all necessary to publish events.

### Consumer with persistent state

We want to develop the example so it is slightly more realistic. In particular, we want the consumer to store updates so that it has some form of persistent state. To accommodate this angle, our consumer will store the most recent update from any sensor that has notified it. Then whenever its knowledge of the sensors is changed, it will print the most recent status of every sensor that has notified it.

For our new consumer with state, we added a detailed event format, that consists of more information than the notification itself. We chose this as an example to show how someone could use the receive time that ICT-Notify passes to our notification callback. More importantly, we defer some of the event processing to a new function in our consumer class called handleEvents. Our onNotificationUpdateWithTime function parses the notification list into the new detailed event format, and then hands over a list of these detailed events to our handleEvents function for processing. The handleEvents function simply updates our sensor knowledge if any of the detailed events contain new information, either an update from a pre-existing sensor or a notification from a new sensor entirely. We show the code excerpts of the modified onNotificationUpdateWithTime, handleEvents, and printStatus functions below.

```C++
void
onNotificationUpdateWithTime(uint64_t receivedTime,
                             const NotificationMap& notiMap)
{
    std::vector<DetailedEvent> events;
    for (auto& map_itr : notiMap)
    {
        for (auto& noti : map_itr.second)
        {
            if (DEBUG) {
                std::cout << "application received notification (t = "
                          << receivedTime << "): " << noti << std::endl;
            }

            int status = std::stoi( noti.get(-1).toUri() );
            double longitude = std::stod( noti.get(-2).toUri() );
            double latitude = std::stod( noti.get(-3).toUri() );
            std::string entityName( noti.get(-4).toUri() );
                
            events.emplace_back( DetailedEvent(receivedTime,
                                               latitude, longitude,
                                               status, entityName) );
        }
    }

    handleEvents( std::move(events) );
}

void
handleEvents(std::vector<DetailedEvent>&& events)
{
    for (auto &event : events)
    {
        auto mapItr = recentUpdates.find(event.entityName);
        // if name is already in map, keep the most recent update only
        if ( mapItr != recentUpdates.end() )
        {
            if (mapItr->second.rxTime < event.rxTime) {
                mapItr->second = event;
                changes = true;
            }
            continue;
        }
        recentUpdates.insert( std::make_pair(event.entityName, event) );
        changes = true;
    }
}

void printStatus()
{
    std::cout << "**Status**\n";
    for (auto entry : recentUpdates)
    {
        std::cout << entry.first << " (t = " << entry.second.rxTime << "): "
                  << entry.second.latitude << "," << entry.second.longitude << "\t"
                  << status2str( (int) entry.second.status) << "\n";
    }
    std::cout << std::endl;
}
```

All in all, it is fairly straightforward to add additional information to events, or keep persistent state in your consumer class that can be leveraged by the callback provided to ICT-notify. It is also possible, if necessary, to add additional arguments to our notificationCallback function (onNotificationUpdateWithTime), and then add additional placeholder arguments in the std::bind call that we provide the ICT-Notify init function. For example, if a third argument was added to onNotificationUpdateWithTime, the init call could be changed to:

```C++
m_notificationHandler->init(m_fileName,
      std::bind(&NotificationConsumer::onNotificationUpdateWithTime, this, _1, _2, _3));
```
